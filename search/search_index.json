{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Starlite Starlite is a light, opinionated and flexible ASGI API framework built on top of pydantic and Starlette . Installation Using your package manager of choice: pip install starlite OR poetry add starlite OR pipenv install starlite Minimal Example Define your data model using pydantic or any library based on it (see for example ormar, beanie, SQLModel etc.): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 You can alternatively use a dataclass, either the standard library one or the one from pydantic: my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partially_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> User : ... Import your controller into your application's entry-point and pass it to Starlite when instantiating your app: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run you application, use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload The Starlite Project This project builds on top the Starlette ASGI toolkit and pydantic modelling to create a higher-order opinionated framework. The idea to use these two libraries as a basis is of course not new - it was first done in FastAPI, which in this regard (and some others) was a source of inspiration for this framework. Nonetheless, Starlite is not FastAPI - it has a different design, different project goals and a completely different codebase. The goal of this project is to become a community driven project. That is, not to have a single \"owner\" but rather a core team of maintainers that leads the project, as well as community contributors. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. As such, the design of the API breaks from the Starlette design and instead offers an opinionated alternative. Finally, Python OOP is extremely powerful and versatile. While still allowing for function based endpoints, Starlite seeks to build on this by placing class based Controllers at its core.","title":"Overview"},{"location":"#starlite","text":"Starlite is a light, opinionated and flexible ASGI API framework built on top of pydantic and Starlette .","title":"Starlite"},{"location":"#installation","text":"Using your package manager of choice: pip install starlite OR poetry add starlite OR pipenv install starlite","title":"Installation"},{"location":"#minimal-example","text":"Define your data model using pydantic or any library based on it (see for example ormar, beanie, SQLModel etc.): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 You can alternatively use a dataclass, either the standard library one or the one from pydantic: my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partially_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> User : ... Import your controller into your application's entry-point and pass it to Starlite when instantiating your app: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run you application, use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload","title":"Minimal Example"},{"location":"#the-starlite-project","text":"This project builds on top the Starlette ASGI toolkit and pydantic modelling to create a higher-order opinionated framework. The idea to use these two libraries as a basis is of course not new - it was first done in FastAPI, which in this regard (and some others) was a source of inspiration for this framework. Nonetheless, Starlite is not FastAPI - it has a different design, different project goals and a completely different codebase. The goal of this project is to become a community driven project. That is, not to have a single \"owner\" but rather a core team of maintainers that leads the project, as well as community contributors. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. As such, the design of the API breaks from the Starlette design and instead offers an opinionated alternative. Finally, Python OOP is extremely powerful and versatile. While still allowing for function based endpoints, Starlite seeks to build on this by placing class based Controllers at its core.","title":"The Starlite Project"},{"location":"contributing/","text":"Contributing To contribute code changes or update the documentation, please follow these steps: Fork the upstream repository and clone the fork locally. Install poetry , and install the project's dependencies with poetry install Install pre-commit by running pre-commit install Make whatever changes and additions you wish and commit these - please try to keep your commit history clean. Create a pull request to the main repository with an explanation of your changes Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.","title":"Contributing"},{"location":"contributing/#contributing","text":"To contribute code changes or update the documentation, please follow these steps: Fork the upstream repository and clone the fork locally. Install poetry , and install the project's dependencies with poetry install Install pre-commit by running pre-commit install Make whatever changes and additions you wish and commit these - please try to keep your commit history clean. Create a pull request to the main repository with an explanation of your changes Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.","title":"Contributing"},{"location":"license/","text":"License MIT License Copyright \u00a9 2021-2022 Na'aman Hirschfeld Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2021-2022 Na'aman Hirschfeld Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"migration/","text":"Migration to Starlite Migrating from either Starlette or FastAPI to Starlite is not very difficult because the two frameworks are for the most part compatible. So what will need to be changes? LifeCycle If you use the Starlette/FastAPI lifecycle kwarg with an AsyncContextManager to bootstrap your application, you will need to convert it to use the on_startup and on_shutdown hooks. Otherwise, using lifecycle management is identical. Routing Decorators Starlite does not include any decorator as part of the Router or Starlite instances. All routes have to be declared using route handlers - in standalone functions or Controller methods. You then have to register them with the app, either by first registering them on a router and then registering the router on the app, or by registering them directly on the app. See the registering routes part of the documentation for details. Routing Classes As discussed in the relation to starlette routing section of the documentation, Starlite does not extend the Starlette routing classes and instead implements its own versions of these. You will need to use the Starlite Router classes instead of their equivalents from the other frameworks. There are some differences between the Starlite class and those from the other frameworks - The Starlite version is not an ASGI app, the only ASGI app is the Starlite app and any middlewares you pass to it. The Starlite version does not include decorators, instead you have to use route handlers . The Starlite version does not support lifecycle hooks, instead you have to handle all of your lifecycle management in the app layer. If you use the Starlette Route instances directly, you will need to replace these with route handlers . Important The Starlette Mount class is replaced by the Starlite Router . The Host class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different microservices rather than use this kind of routing Dependency Injection The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depend class. In Starlite you declare dependencies always using a dictionary with a string key, and a value wrapped in an instance of the Provide class. Authentication FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending the Starlite AbstractAuthenticationMiddleware class . Third Party Packages Third party packages create for Starlette and FastAPI should by and large be compatible with Starlite. The only exceptions are for packages that use the FastAPI dependency injection system as a basis - these will not work as such.","title":"Migration to Starlite"},{"location":"migration/#migration-to-starlite","text":"Migrating from either Starlette or FastAPI to Starlite is not very difficult because the two frameworks are for the most part compatible. So what will need to be changes?","title":"Migration to Starlite"},{"location":"migration/#lifecycle","text":"If you use the Starlette/FastAPI lifecycle kwarg with an AsyncContextManager to bootstrap your application, you will need to convert it to use the on_startup and on_shutdown hooks. Otherwise, using lifecycle management is identical.","title":"LifeCycle"},{"location":"migration/#routing-decorators","text":"Starlite does not include any decorator as part of the Router or Starlite instances. All routes have to be declared using route handlers - in standalone functions or Controller methods. You then have to register them with the app, either by first registering them on a router and then registering the router on the app, or by registering them directly on the app. See the registering routes part of the documentation for details.","title":"Routing Decorators"},{"location":"migration/#routing-classes","text":"As discussed in the relation to starlette routing section of the documentation, Starlite does not extend the Starlette routing classes and instead implements its own versions of these. You will need to use the Starlite Router classes instead of their equivalents from the other frameworks. There are some differences between the Starlite class and those from the other frameworks - The Starlite version is not an ASGI app, the only ASGI app is the Starlite app and any middlewares you pass to it. The Starlite version does not include decorators, instead you have to use route handlers . The Starlite version does not support lifecycle hooks, instead you have to handle all of your lifecycle management in the app layer. If you use the Starlette Route instances directly, you will need to replace these with route handlers . Important The Starlette Mount class is replaced by the Starlite Router . The Host class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different microservices rather than use this kind of routing","title":"Routing Classes"},{"location":"migration/#dependency-injection","text":"The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depend class. In Starlite you declare dependencies always using a dictionary with a string key, and a value wrapped in an instance of the Provide class.","title":"Dependency Injection"},{"location":"migration/#authentication","text":"FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending the Starlite AbstractAuthenticationMiddleware class .","title":"Authentication"},{"location":"migration/#third-party-packages","text":"Third party packages create for Starlette and FastAPI should by and large be compatible with Starlite. The only exceptions are for packages that use the FastAPI dependency injection system as a basis - these will not work as such.","title":"Third Party Packages"},{"location":"usage/0-the-starlite-app/","text":"The Starlite App At the root of every Starlite application is an instance of the Starlite class or a subclass of it. Typically, this code will be placed in a file called main.py at the project's source folder root. Creating an app is straightforward, with the only required kwarg being list of Controllers, Routers or route_handlers : my_app/main.py from starlite import Starlite , get @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) The app instance is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. See registering routes for full details. You can additionally pass the following kwargs to the Starlite constructor: allowed_hosts : A list of allowed hosts. If set this enables the AllowedHostsMiddleware . See middleware . cors_config : An instance of starlite.config.CORSConfig . If set this enables the CORSMiddleware . See middleware . debug : A boolean flag toggling debug mode on and off, if True, 404 errors will be rendered as HTML with a stack trace. This option should not be used in production. Default to False . dependencies : A dictionary mapping dependency providers. See dependency-injection . exception_handlers : A dictionary mapping exceptions or exception codes to handler functions. See exception-handlers . guards : A list of callables. See guards . middleware : A list of classes adhering to the Starlite MiddlewareProtocol , instance of the Starlette Middleware class, or subclasses of the Starlette BaseHTTPMiddleware class. See middleware . on_shutdown : A list of callables that are called during the application shutdown. See life-cycle . on_startup : A list of callables that are called during the application startup. See life-cycle . openapi_config : An instance of starlite.config.OpenAPIConfig . Defaults to the baseline config. See open-api . redirect_slashes : A boolean flag dictating whether to redirect urls ending with a trailing slash to urls without a trailing slash if no match is found. Defaults to True . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . Lifecycle Starlette, on top of which StatLite is built, supports two kinds of application lifecycle management - on_statup / on_shutdown hooks, which accept a sequence of callables, and lifespan , which accepts an AsyncContextManager . To simplify matters, Starlite only supports the on_statup / on_shutdown hooks. To use these you can pass a list of callables, whats called \"event handlers\" in Starlette, which will be called during the application startup or shutdown. These callables can be either sync or async - methods or functions. A classic use case for this is database connectivity. Often you will want to establish the connection once - on application startup, and then close the connection on shutdown. For example, lets assume we create a connection to a Postgres DB using the async engine from SQLAlchemy , and we therefore opt to create two functions, one to get or create the connection, and another to close it: my_app/postgres.py from os import environ from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlette.datastructures import State state = State () def get_postgres_connection () -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" postgres_connection_string = environ . get ( \"POSTGRES_CONNECTION_STRING\" , \"\" ) if not postgres_connection_string : raise ValueError ( \"Missing ENV Variable POSTGRES_CONNECTION_STRING\" ) if not state . get ( \"postgres_connection\" ): state [ \"postgres_connection\" ] = create_async_engine ( postgres_connection_string ) return cast ( AsyncEngine , state [ \"postgres_connection\" ]) async def close_postgres_connection (): \"\"\"Closes the postgres connection stored in the given State object\"\"\" if state . get ( \"postgres_connection\" ): await cast ( AsyncEngine , state [ \"postgres_connection\" ]) . dispose () We now simply need to pass these to the Starlite init method to ensure these are called correctly: my_app/main.py from starlite import Starlite from my_app.postgres import get_postgres_connection , close_postgres_connection app = Starlite ( on_startup = [ get_postgres_connection ], on_shutdown = [ close_postgres_connection ]) Logging Another thing most applications will need to set up as part of startup is logging. Although Starlite does not configure logging for you, it does come with a convenience pydantic model called LoggingConfig , which you can use like so: my_app/main.py from starlite import Starlite , LoggingConfig my_app_logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"console\" ], } } ) app = Starlite ( on_startup = [ my_app_logging_config . configure ]) LoggingConfig is merely a convenience wrapper around the standard library's DictConfig options, which can be rather confusing. In the above we defined a logger for the \"my*app\" namespace with a level of \"INFO\", i.e. only messages of INFO severity or above will be logged by it, using the LoggingConfig default console handler, which will emit logging messages to * sys.stderr_. You do not need to use LoggingConfig to set up logging. This is completely decoupled from Starlite itself, and you are free to use whatever solution you want for this (e.g. loguru ). Still, if you do setup up logging - then the on_startup hook is a good place to do this. Exceptions The Starlite HTTPException class receives 3 optional kwargs: detail : The error message. Defaults to the \"phrase\" of the status code using http.HttpStatus . status_code : A valid HTTP error status code (4xx or 5xx range). Defaults to 500. extra : A dictionary of arbitrary values. This dictionary will be serialized and sent as part of the response. Defaults to None . Starlite has several pre-configured exception subclasses with pre-set error codes that you can use: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503. Exception Handling Starlite handles all errors by default by transforming them into JSON responses. If the errors are instances of either the starlette.exceptions.HTTPException or the starlite.exceptions.HTTPException , the responses will include the appropriate status_code. Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary mapping either error codes or exception classes to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, )","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/#the-starlite-app","text":"At the root of every Starlite application is an instance of the Starlite class or a subclass of it. Typically, this code will be placed in a file called main.py at the project's source folder root. Creating an app is straightforward, with the only required kwarg being list of Controllers, Routers or route_handlers : my_app/main.py from starlite import Starlite , get @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) The app instance is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. See registering routes for full details. You can additionally pass the following kwargs to the Starlite constructor: allowed_hosts : A list of allowed hosts. If set this enables the AllowedHostsMiddleware . See middleware . cors_config : An instance of starlite.config.CORSConfig . If set this enables the CORSMiddleware . See middleware . debug : A boolean flag toggling debug mode on and off, if True, 404 errors will be rendered as HTML with a stack trace. This option should not be used in production. Default to False . dependencies : A dictionary mapping dependency providers. See dependency-injection . exception_handlers : A dictionary mapping exceptions or exception codes to handler functions. See exception-handlers . guards : A list of callables. See guards . middleware : A list of classes adhering to the Starlite MiddlewareProtocol , instance of the Starlette Middleware class, or subclasses of the Starlette BaseHTTPMiddleware class. See middleware . on_shutdown : A list of callables that are called during the application shutdown. See life-cycle . on_startup : A list of callables that are called during the application startup. See life-cycle . openapi_config : An instance of starlite.config.OpenAPIConfig . Defaults to the baseline config. See open-api . redirect_slashes : A boolean flag dictating whether to redirect urls ending with a trailing slash to urls without a trailing slash if no match is found. Defaults to True . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers .","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/#lifecycle","text":"Starlette, on top of which StatLite is built, supports two kinds of application lifecycle management - on_statup / on_shutdown hooks, which accept a sequence of callables, and lifespan , which accepts an AsyncContextManager . To simplify matters, Starlite only supports the on_statup / on_shutdown hooks. To use these you can pass a list of callables, whats called \"event handlers\" in Starlette, which will be called during the application startup or shutdown. These callables can be either sync or async - methods or functions. A classic use case for this is database connectivity. Often you will want to establish the connection once - on application startup, and then close the connection on shutdown. For example, lets assume we create a connection to a Postgres DB using the async engine from SQLAlchemy , and we therefore opt to create two functions, one to get or create the connection, and another to close it: my_app/postgres.py from os import environ from typing import cast from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlette.datastructures import State state = State () def get_postgres_connection () -> AsyncEngine : \"\"\"Returns the Postgres connection. If it doesn't exist, creates it and saves it in a State object\"\"\" postgres_connection_string = environ . get ( \"POSTGRES_CONNECTION_STRING\" , \"\" ) if not postgres_connection_string : raise ValueError ( \"Missing ENV Variable POSTGRES_CONNECTION_STRING\" ) if not state . get ( \"postgres_connection\" ): state [ \"postgres_connection\" ] = create_async_engine ( postgres_connection_string ) return cast ( AsyncEngine , state [ \"postgres_connection\" ]) async def close_postgres_connection (): \"\"\"Closes the postgres connection stored in the given State object\"\"\" if state . get ( \"postgres_connection\" ): await cast ( AsyncEngine , state [ \"postgres_connection\" ]) . dispose () We now simply need to pass these to the Starlite init method to ensure these are called correctly: my_app/main.py from starlite import Starlite from my_app.postgres import get_postgres_connection , close_postgres_connection app = Starlite ( on_startup = [ get_postgres_connection ], on_shutdown = [ close_postgres_connection ])","title":"Lifecycle"},{"location":"usage/0-the-starlite-app/#logging","text":"Another thing most applications will need to set up as part of startup is logging. Although Starlite does not configure logging for you, it does come with a convenience pydantic model called LoggingConfig , which you can use like so: my_app/main.py from starlite import Starlite , LoggingConfig my_app_logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"console\" ], } } ) app = Starlite ( on_startup = [ my_app_logging_config . configure ]) LoggingConfig is merely a convenience wrapper around the standard library's DictConfig options, which can be rather confusing. In the above we defined a logger for the \"my*app\" namespace with a level of \"INFO\", i.e. only messages of INFO severity or above will be logged by it, using the LoggingConfig default console handler, which will emit logging messages to * sys.stderr_. You do not need to use LoggingConfig to set up logging. This is completely decoupled from Starlite itself, and you are free to use whatever solution you want for this (e.g. loguru ). Still, if you do setup up logging - then the on_startup hook is a good place to do this.","title":"Logging"},{"location":"usage/0-the-starlite-app/#exceptions","text":"The Starlite HTTPException class receives 3 optional kwargs: detail : The error message. Defaults to the \"phrase\" of the status code using http.HttpStatus . status_code : A valid HTTP error status code (4xx or 5xx range). Defaults to 500. extra : A dictionary of arbitrary values. This dictionary will be serialized and sent as part of the response. Defaults to None . Starlite has several pre-configured exception subclasses with pre-set error codes that you can use: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503.","title":"Exceptions"},{"location":"usage/0-the-starlite-app/#exception-handling","text":"Starlite handles all errors by default by transforming them into JSON responses. If the errors are instances of either the starlette.exceptions.HTTPException or the starlite.exceptions.HTTPException , the responses will include the appropriate status_code. Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary mapping either error codes or exception classes to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, )","title":"Exception Handling"},{"location":"usage/1-routers-and-controllers/","text":"Routers and Controllers In most cases an API is composed of multiple endpoints, often with different sub-paths. Starlite offers two class components that make this simple to achieve - Router and Controller . Controllers Controllers are subclasses of the Starlite Controller class that are used to organize endpoints under a specific sub-path. You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The distinct advantage of using controllers is that they allow both code sharing using OOP techniques and make the code better organized by promoting concern based code splitting. my_app/orders/controllers/user_order_controller.py from pydantic import UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial from my_app.orders.models import UserOrder class UserOrderController ( Controller ): path = \"/user\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ]) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> UserOrder : ... The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller, while retrieve_user_order has the path /user/{order_id:uuid}\" . Note Controller methods do not have to declare a path kwarg in the decorator - if no path kwarg is defined for them, then the controller path will be set as their path. Aside from the path class variable, which must be set, you can also set the following optional class variables: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . Routers my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) The Starlite Router class is used to organize sub-paths under a common namespace. In the above, it registers two different controllers, and each controller's respective path is combined with the router's path. Assuming that the UserOrderController defines a path of \"/user\" and PartnerOrderController defines a path of \" /partner\", their paths will be \"/orders/user\" and \"order/partner\" respectively. Aside from path and route_handlers which are required kwargs, you can also pass the following kwargs to Router: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . Registering Routes At the root of every Starlite application there is an instance of Starlite, on which the root level controllers, routers and/or router-handlers are registered, for example: my_app/main.py from starlite import get , Starlite from users import UserController from orders import order_router @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check , UserController , order_router ]) The root level components registered on the app have whatever path is defined on them without anything appended to it. Thus, the health_check function above is available on \"/\" and the methods of UserController are available on \" /users\". To handle more complex path schemas you should use routers, which can register Controllers, individual functions but also other routers: my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) Once order_router is registered on base_router , the controllers registered on it will be respectively available on: \"/base/orders/user\" and \"/base/order/partner\" respectively. Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised. Registering Controllers Multiple Times Unlike routers, which can only be registered once, the same controller can be registered on different routers: my_app/users/router.py from starlite import Router from my_app.user.controllers import UserController internal_router = Router ( path = \"/internal\" , route_handlers = [ UserController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ UserController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ UserController ]) In the above, the same UserController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore , in the above example, three different instance of UserController will be created, each mounted on a different sub-path, e.g. \"/internal/users\", \"/partner/users\" and \"/consumer/users\". Registering Standalone Route Handlers Multiple Times You can also register standalone route handler handlers multiple times: my_app/users/router.py from starlite import Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) This is possible because the route handler is copied when registered. Thus, each router has its own unique instance of the route handler rather than the same one. Path behaviour is identical to controllers, namely, the route handler function will be accessible in the following paths: \"/internal/handler\", \"/partner/handler\" and \"/consumer/handler\". Relation to Starlette Routing Although Starlite uses the Starlette BaseRoute class as a basis, Starlite does not extend or use the Starlette routing system as is. That is to say, the Starlite HTTPRoute , WebSocketRoute and Router classes do not extend their Starlette equivalents, but are rather independent implementations. Its important to note the following: Starlite Routers have a smaller api surface and do not expose decorators. Starlite Routers and Routes are not standalone ASGI apps and always depend upon a Starlite app instance. Starlite enforces a simple routing structure and doesn't support multiple-hosts and complex mounts. The reason for this decision is to enforce a simple routing pattern. It's true that this eliminates certain possibilities, for example - you cannot re-use paths based on different \"Host\" headers, as you can in Starlette, but this is intentional and is meant to enforce best practices.","title":"Routers and Controllers"},{"location":"usage/1-routers-and-controllers/#routers-and-controllers","text":"In most cases an API is composed of multiple endpoints, often with different sub-paths. Starlite offers two class components that make this simple to achieve - Router and Controller .","title":"Routers and Controllers"},{"location":"usage/1-routers-and-controllers/#controllers","text":"Controllers are subclasses of the Starlite Controller class that are used to organize endpoints under a specific sub-path. You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The distinct advantage of using controllers is that they allow both code sharing using OOP techniques and make the code better organized by promoting concern based code splitting. my_app/orders/controllers/user_order_controller.py from pydantic import UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial from my_app.orders.models import UserOrder class UserOrderController ( Controller ): path = \"/user\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ]) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> UserOrder : ... The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller, while retrieve_user_order has the path /user/{order_id:uuid}\" . Note Controller methods do not have to declare a path kwarg in the decorator - if no path kwarg is defined for them, then the controller path will be set as their path. Aside from the path class variable, which must be set, you can also set the following optional class variables: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers .","title":"Controllers"},{"location":"usage/1-routers-and-controllers/#routers","text":"my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) The Starlite Router class is used to organize sub-paths under a common namespace. In the above, it registers two different controllers, and each controller's respective path is combined with the router's path. Assuming that the UserOrderController defines a path of \"/user\" and PartnerOrderController defines a path of \" /partner\", their paths will be \"/orders/user\" and \"order/partner\" respectively. Aside from path and route_handlers which are required kwargs, you can also pass the following kwargs to Router: dependencies : A dictionary mapping dependency providers. See dependency-injection . guards : A list of callables. See guards . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers .","title":"Routers"},{"location":"usage/1-routers-and-controllers/#registering-routes","text":"At the root of every Starlite application there is an instance of Starlite, on which the root level controllers, routers and/or router-handlers are registered, for example: my_app/main.py from starlite import get , Starlite from users import UserController from orders import order_router @get ( path = \"/\" ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check , UserController , order_router ]) The root level components registered on the app have whatever path is defined on them without anything appended to it. Thus, the health_check function above is available on \"/\" and the methods of UserController are available on \" /users\". To handle more complex path schemas you should use routers, which can register Controllers, individual functions but also other routers: my_app/order/router.py from starlite import Router from my_app.order.controllers import UserOrderController , PartnerOrderController order_router = Router ( path = \"/orders\" , route_handlers = [ UserOrderController , PartnerOrderController ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) Once order_router is registered on base_router , the controllers registered on it will be respectively available on: \"/base/orders/user\" and \"/base/order/partner\" respectively. Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.","title":"Registering Routes"},{"location":"usage/1-routers-and-controllers/#registering-controllers-multiple-times","text":"Unlike routers, which can only be registered once, the same controller can be registered on different routers: my_app/users/router.py from starlite import Router from my_app.user.controllers import UserController internal_router = Router ( path = \"/internal\" , route_handlers = [ UserController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ UserController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ UserController ]) In the above, the same UserController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore , in the above example, three different instance of UserController will be created, each mounted on a different sub-path, e.g. \"/internal/users\", \"/partner/users\" and \"/consumer/users\".","title":"Registering Controllers Multiple Times"},{"location":"usage/1-routers-and-controllers/#registering-standalone-route-handlers-multiple-times","text":"You can also register standalone route handler handlers multiple times: my_app/users/router.py from starlite import Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) This is possible because the route handler is copied when registered. Thus, each router has its own unique instance of the route handler rather than the same one. Path behaviour is identical to controllers, namely, the route handler function will be accessible in the following paths: \"/internal/handler\", \"/partner/handler\" and \"/consumer/handler\".","title":"Registering Standalone Route Handlers Multiple Times"},{"location":"usage/1-routers-and-controllers/#relation-to-starlette-routing","text":"Although Starlite uses the Starlette BaseRoute class as a basis, Starlite does not extend or use the Starlette routing system as is. That is to say, the Starlite HTTPRoute , WebSocketRoute and Router classes do not extend their Starlette equivalents, but are rather independent implementations. Its important to note the following: Starlite Routers have a smaller api surface and do not expose decorators. Starlite Routers and Routes are not standalone ASGI apps and always depend upon a Starlite app instance. Starlite enforces a simple routing structure and doesn't support multiple-hosts and complex mounts. The reason for this decision is to enforce a simple routing pattern. It's true that this eliminates certain possibilities, for example - you cannot re-use paths based on different \"Host\" headers, as you can in Starlette, but this is intentional and is meant to enforce best practices.","title":"Relation to Starlette Routing"},{"location":"usage/10-openapi/","text":"OpenAPI Starlite has first class OpenAPI support offering the following features: extensive OpenAPI 3.1.0 spec generation integrated Redoc UI Spec Generation Spec Generation utilizes the excellent openapi-schema-pydantic library, which offers a complete implementation of the OpenAPI specs as pydantic models. Starlite generates OpenAPI specs version 3.1.0 - the latest version of the specification . App Level Configuration OpenAPI schema generation is enabled by default. To configure it you can pass an instance of starlite.config.OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required kwargs, you can pass the following optional kwargs: create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . contact : An instance of the Contact model. description : Description text. external_docs : An instance of the ExternalDocumentation model. license : An instance of the License model. security : An instance of the SecurityRequirement model. servers : A list of Server model instances. defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag model instances. terms_of_service : A url to a page containing the terms of service. webhooks : A string keyed dictionary of PathItem model instances. Note All models listed above are exported from openapi-schema-pydantic rather than Starlite. Disable Schema Generation If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = None ) Route Handler Configuration By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema to False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also affect the schema by enriching and/or modifying it using the following kwargs: tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function). Accessing the OpenAPI Schema The generated schema is an instance of the OpenAPI pydantic model, and you can access it in any route handler like so: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> None : schema = request . app . openapi_schema ... The OpenAPI Controller Starlite includes a pre-configured controller called OpenAPIController which exposes three endpoints: /schema/openapi.yaml , allowing for download of the OpenAPI schema as YAML, using the application/vnd.oai.openapi Content-Type. /schema/openapi.json , allowing for download of the OpenAPI schema as JSON, using the application/vnd.oai.openapi+json Content-Type. /schema/redoc , which serves a Redoc UI static website for the OpenAPI docs. Important prior to version 0.3.0 there was only a single download endpoint by default and its path was /schema If you would like to modify the endpoints, add new endpoints, change the styling of redoc etc., you can subclass the OpenAPIController and then pass your subclass to the OpenAPIConfig . For example, lets say we wanted to change the base path from \"/schema\" to \"/api-docs\": my_app/openapi.py from starlite import OpenAPIController class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" We would then use the subclassed controller like so: from starlite import Starlite , OpenAPIConfig from my_app.openapi import MyOpenAPIController app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( openapI_controller = MyOpenAPIController ), )","title":"OpenAPI"},{"location":"usage/10-openapi/#openapi","text":"Starlite has first class OpenAPI support offering the following features: extensive OpenAPI 3.1.0 spec generation integrated Redoc UI","title":"OpenAPI"},{"location":"usage/10-openapi/#spec-generation","text":"Spec Generation utilizes the excellent openapi-schema-pydantic library, which offers a complete implementation of the OpenAPI specs as pydantic models. Starlite generates OpenAPI specs version 3.1.0 - the latest version of the specification .","title":"Spec Generation"},{"location":"usage/10-openapi/#app-level-configuration","text":"OpenAPI schema generation is enabled by default. To configure it you can pass an instance of starlite.config.OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required kwargs, you can pass the following optional kwargs: create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . contact : An instance of the Contact model. description : Description text. external_docs : An instance of the ExternalDocumentation model. license : An instance of the License model. security : An instance of the SecurityRequirement model. servers : A list of Server model instances. defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag model instances. terms_of_service : A url to a page containing the terms of service. webhooks : A string keyed dictionary of PathItem model instances. Note All models listed above are exported from openapi-schema-pydantic rather than Starlite.","title":"App Level Configuration"},{"location":"usage/10-openapi/#disable-schema-generation","text":"If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : my_app/main.py from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = None )","title":"Disable Schema Generation"},{"location":"usage/10-openapi/#route-handler-configuration","text":"By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema to False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also affect the schema by enriching and/or modifying it using the following kwargs: tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function).","title":"Route Handler Configuration"},{"location":"usage/10-openapi/#accessing-the-openapi-schema","text":"The generated schema is an instance of the OpenAPI pydantic model, and you can access it in any route handler like so: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> None : schema = request . app . openapi_schema ...","title":"Accessing the OpenAPI Schema"},{"location":"usage/10-openapi/#the-openapi-controller","text":"Starlite includes a pre-configured controller called OpenAPIController which exposes three endpoints: /schema/openapi.yaml , allowing for download of the OpenAPI schema as YAML, using the application/vnd.oai.openapi Content-Type. /schema/openapi.json , allowing for download of the OpenAPI schema as JSON, using the application/vnd.oai.openapi+json Content-Type. /schema/redoc , which serves a Redoc UI static website for the OpenAPI docs. Important prior to version 0.3.0 there was only a single download endpoint by default and its path was /schema If you would like to modify the endpoints, add new endpoints, change the styling of redoc etc., you can subclass the OpenAPIController and then pass your subclass to the OpenAPIConfig . For example, lets say we wanted to change the base path from \"/schema\" to \"/api-docs\": my_app/openapi.py from starlite import OpenAPIController class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" We would then use the subclassed controller like so: from starlite import Starlite , OpenAPIConfig from my_app.openapi import MyOpenAPIController app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( openapI_controller = MyOpenAPIController ), )","title":"The OpenAPI Controller"},{"location":"usage/11-testing/","text":"Testing Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box. Test Client Starlite extends the Starlette testing client, which in turn is built using the requests library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient from my_app.main import app client = TestClient ( app = app ) def test_health_check (): response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient def test_health_check ( test_client : TestClient ): response = test_client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Creating a Testing App Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Create a Test Request Another helper is create_test_request , which creates an instance of starlite.request.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException , HttpMethod , create_test_request from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = create_test_request ( http_method = HttpMethod . GET ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) Aside from http_method , which is required , you can pass the following optional kwargs to create_test_request : scheme : \"http\" or \"https\". Defaults to http . server : Server domain. Defaults to test.org . port : Request port. Defaults to 3000 . root_path : Root path. Defaults to / . path : Path. Defaults to empty string. query : A string keyed dictionary of query parameters - can contain lists. Defaults to None . headers : A string keyed dictionary of header parameters. Defaults to None . cookie : A string representing a cookie. Defaults to None . content : A dictionary or a pydantic model that forms the request body. Defaults to None . request_media_type : Media type of the request, defaults to RequestEncodingType.JSON . app : An instance of Starlite to set as request.app . Defaults to None .","title":"Testing"},{"location":"usage/11-testing/#testing","text":"Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box.","title":"Testing"},{"location":"usage/11-testing/#test-client","text":"Starlite extends the Starlette testing client, which in turn is built using the requests library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient from my_app.main import app client = TestClient ( app = app ) def test_health_check (): response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import TestClient def test_health_check ( test_client : TestClient ): response = test_client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Test Client"},{"location":"usage/11-testing/#creating-a-testing-app","text":"Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlette.status import HTTP_200_OK from starlite import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Creating a Testing App"},{"location":"usage/11-testing/#create-a-test-request","text":"Another helper is create_test_request , which creates an instance of starlite.request.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException , HttpMethod , create_test_request from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = create_test_request ( http_method = HttpMethod . GET ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) Aside from http_method , which is required , you can pass the following optional kwargs to create_test_request : scheme : \"http\" or \"https\". Defaults to http . server : Server domain. Defaults to test.org . port : Request port. Defaults to 3000 . root_path : Root path. Defaults to / . path : Path. Defaults to empty string. query : A string keyed dictionary of query parameters - can contain lists. Defaults to None . headers : A string keyed dictionary of header parameters. Defaults to None . cookie : A string representing a cookie. Defaults to None . content : A dictionary or a pydantic model that forms the request body. Defaults to None . request_media_type : Media type of the request, defaults to RequestEncodingType.JSON . app : An instance of Starlite to set as request.app . Defaults to None .","title":"Create a Test Request"},{"location":"usage/2-route-handlers/","text":"Route Handlers Route handlers are the core of Starlite. They are constructed by decorating a function or method with one of the handler decorators exported from Starlite. HTTP Route Handlers The base decorator is called route : from starlite import HttpMethod , route @route ( path = \"/my-endpoint\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... What route does is wrap the given function or class method and replace it with an instance of the class HTTPRouteHandler . In fact, route is merely an alias for HTTPRouteHandler , thus you could have done this instead: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/my-endpoint\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... Important A function decorated by route or any of the other route handler decorator must have an annotated return value, even if the return value is None as in the above example. This limitation is enforced to ensure consistent schema generation, as well as stronger typing. The route decorator accepts the following required kwargs - path ( required ) - a path string, with or without path parameters . http_method ( required ) - a member of the enum starlite.enums.HttpMethod or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . Additionally, you can pass the following optional kwargs: status_code : the status code for a success response. If not specified, a default value will be used , unless you specify more than one http method, in which case you must specify a value or an exception will be raised. media_type : A string or a member of the enum starlite.enums.MediaType , which specifies the MIME Media Type for the response. Defaults to MediaType.JSON . See media-type . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . dependencies : A dictionary mapping dependency providers. See dependency-injection . opt : String keyed dictionary of arbitrary value that can be used by guards . And the following kwargs, which affect OpenAPI schema generation include_in_schema : A boolean flag dictating whether the given route handler will appear in the generated OpenAPI schema. Defaults to True . tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. Semantic Handler Decorators Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from typing import List from starlite import Partial , delete , get , patch , post , put from my_app.models import Resource @get ( path = \"/resources\" ) def list_resources () -> List [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of PathHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions. Websocket Route Handlers Info This feature is available from v0.2.0 onwards Alongside the HTTP Route handlers discussed above, Starlite also support Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is also an aliased class, in this case - of the WebsocketRouteHandler . Thus. you can write the above like so: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. If this is missing an exception will be raised. they must have a return annotation of None . Any other annotation, or lack thereof, will raise an exception. Additionally, they should be async because the socket interface is async - but this is not enforced. You will not be able to do anything meaningful without this and python will raise errors as required. In all other regards websocket handlers function exactly like other route handlers. Note OpenAPI currently does not support websockets. As a result not schema will be generated for websocket route handlers, and you cannot configure any schema related parameters for these. Handler Function Kwargs Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters the request body dependencies Additionally, you can specify the following special kwargs: request : injects the request instance. headers : injects the request headers as a parsed dictionary. query : injects the request query_params as a parsed dictionary. cookies : injects the request cookies as a parsed dictionary. For example: from typing import Any , Dict from starlite import Request , get @get ( path = \"/\" ) def my_request_handler ( request : Request , headers : Dict [ str , Any ], query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ...","title":"Route Handlers"},{"location":"usage/2-route-handlers/#route-handlers","text":"Route handlers are the core of Starlite. They are constructed by decorating a function or method with one of the handler decorators exported from Starlite.","title":"Route Handlers"},{"location":"usage/2-route-handlers/#http-route-handlers","text":"The base decorator is called route : from starlite import HttpMethod , route @route ( path = \"/my-endpoint\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... What route does is wrap the given function or class method and replace it with an instance of the class HTTPRouteHandler . In fact, route is merely an alias for HTTPRouteHandler , thus you could have done this instead: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/my-endpoint\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... Important A function decorated by route or any of the other route handler decorator must have an annotated return value, even if the return value is None as in the above example. This limitation is enforced to ensure consistent schema generation, as well as stronger typing. The route decorator accepts the following required kwargs - path ( required ) - a path string, with or without path parameters . http_method ( required ) - a member of the enum starlite.enums.HttpMethod or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . Additionally, you can pass the following optional kwargs: status_code : the status code for a success response. If not specified, a default value will be used , unless you specify more than one http method, in which case you must specify a value or an exception will be raised. media_type : A string or a member of the enum starlite.enums.MediaType , which specifies the MIME Media Type for the response. Defaults to MediaType.JSON . See media-type . response_class : A custom response class to be used as the app default. See using-custom-responses . response_headers : A dictionary of ResponseHeader instances. See response-headers . dependencies : A dictionary mapping dependency providers. See dependency-injection . opt : String keyed dictionary of arbitrary value that can be used by guards . And the following kwargs, which affect OpenAPI schema generation include_in_schema : A boolean flag dictating whether the given route handler will appear in the generated OpenAPI schema. Defaults to True . tags : a list of openapi-pydantic Tag models, which correlate to the tag specification . summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/#semantic-handler-decorators","text":"Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from typing import List from starlite import Partial , delete , get , patch , post , put from my_app.models import Resource @get ( path = \"/resources\" ) def list_resources () -> List [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of PathHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions.","title":"Semantic Handler Decorators"},{"location":"usage/2-route-handlers/#websocket-route-handlers","text":"Info This feature is available from v0.2.0 onwards Alongside the HTTP Route handlers discussed above, Starlite also support Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is also an aliased class, in this case - of the WebsocketRouteHandler . Thus. you can write the above like so: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. If this is missing an exception will be raised. they must have a return annotation of None . Any other annotation, or lack thereof, will raise an exception. Additionally, they should be async because the socket interface is async - but this is not enforced. You will not be able to do anything meaningful without this and python will raise errors as required. In all other regards websocket handlers function exactly like other route handlers. Note OpenAPI currently does not support websockets. As a result not schema will be generated for websocket route handlers, and you cannot configure any schema related parameters for these.","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/#handler-function-kwargs","text":"Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters the request body dependencies Additionally, you can specify the following special kwargs: request : injects the request instance. headers : injects the request headers as a parsed dictionary. query : injects the request query_params as a parsed dictionary. cookies : injects the request cookies as a parsed dictionary. For example: from typing import Any , Dict from starlite import Request , get @get ( path = \"/\" ) def my_request_handler ( request : Request , headers : Dict [ str , Any ], query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ...","title":"Handler Function Kwargs"},{"location":"usage/3-parameters/","text":"Parameters Path Parameters from starlite import get from my_app.models import User @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : ... In the above there are two components: The path parameter is defined inside the path kwarg passed to the @get decorator in the form {parameter_name:parameter_type} . This definition of the path parameter is based on the Starlette path parameter mechanism. Yet, in difference to Starlette, which allows defining path parameters without defining their types, Starlite enforces this typing, with the following types supported: int , float , str , uuid . The get_user function defines a parameter with the same name as defined in the path kwarg. This ensures that the value of the path parameter will be injected into the function when it's called. The types do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: from datetime import datetime from typing import List from starlite import get from my_app.models import Order @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> List [ Order ]: ... The parameter defined inside the path kwarg is typed as int , because the value passed from the frontend will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, its fine to omit it. It will still be validated and added to the openapi schema correctly. Extra Validation and Documentation for Path Params If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from openapi_schema_pydantic import Example from starlite import get , Parameter from my_app.models import Version @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific specification version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = \"https://mywebsite.com/documentation/product#versions\" , ) ) -> Version : ... In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema. Query Parameters To define query parameters simply define them as kwargs in your function declaration: from datetime import datetime from typing import List , Optional from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], page_size : int = 10 , from_date : Optional [ datetime ] = None , to_date : Optional [ datetime ] = None , ) -> List [ Order ]: ... The above is a rather classic example of a paginated \"GET\" request: page is a required query parameter of type int . It has no default value and as such has to be provided or a ValidationException will be raised. page_size is a required query parameter of type int as well, but it has a default value - so it can be omitted in the request. brands is an optional list of strings with a default None value. from_date and to_date are optional date-time values that have a default None value. These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. This works great, but what happens when the request is sent with a non-python naming scheme, such as camelCase ? You could of course simply rename your variables accordingly: from datetime import datetime from typing import Optional , List from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], pageSize : int = 10 , fromDate : Optional [ datetime ] = None , toDate : Optional [ datetime ] = None , ) -> List [ Order ]: ... This doesn't look so good, and tools such as PyLint will complain. The solution here is to use the Parameter function : from datetime import datetime from typing import Optional , List from starlite import get , Parameter from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , page_size : int = Parameter ( query = \"pageSize\" , gt = 0 , le = 100 ), brands : List [ str ] = Parameter ( min_items = 2 , max_items = 5 ), from_Date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), to_date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), ) -> List [ Order ]: ... As you can see, specifying the \"query\" kwarg allows us to remap from one key to another. Furthermore, we can use Parameter for extended validation and documentation, as is done for page_size . Header and Cookie Parameters Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , token : Parameter ( header = \"X-API-KEY\" ), ) -> User : ... OR from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , cookie : Parameter ( cookie = \"my-cookie-param\" ), ) -> User : ... As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters. The Parameter Function Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. Parameter accepts the following optional kwargs: header : The header parameter key for this parameter. A value for this kwarg is required for header parameters. cookie : The cookie parameter key for this parameter. A value for this kwarg is required for cookie parameters. query : The query parameter key for this parameter. examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . required : A boolean flag dictating whether this parameter is required. If set to False , None values will be allowed. Defaults to True . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.","title":"Parameters"},{"location":"usage/3-parameters/#parameters","text":"","title":"Parameters"},{"location":"usage/3-parameters/#path-parameters","text":"from starlite import get from my_app.models import User @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : ... In the above there are two components: The path parameter is defined inside the path kwarg passed to the @get decorator in the form {parameter_name:parameter_type} . This definition of the path parameter is based on the Starlette path parameter mechanism. Yet, in difference to Starlette, which allows defining path parameters without defining their types, Starlite enforces this typing, with the following types supported: int , float , str , uuid . The get_user function defines a parameter with the same name as defined in the path kwarg. This ensures that the value of the path parameter will be injected into the function when it's called. The types do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: from datetime import datetime from typing import List from starlite import get from my_app.models import Order @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> List [ Order ]: ... The parameter defined inside the path kwarg is typed as int , because the value passed from the frontend will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, its fine to omit it. It will still be validated and added to the openapi schema correctly.","title":"Path Parameters"},{"location":"usage/3-parameters/#extra-validation-and-documentation-for-path-params","text":"If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from openapi_schema_pydantic import Example from starlite import get , Parameter from my_app.models import Version @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific specification version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = \"https://mywebsite.com/documentation/product#versions\" , ) ) -> Version : ... In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema.","title":"Extra Validation and Documentation for Path Params"},{"location":"usage/3-parameters/#query-parameters","text":"To define query parameters simply define them as kwargs in your function declaration: from datetime import datetime from typing import List , Optional from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], page_size : int = 10 , from_date : Optional [ datetime ] = None , to_date : Optional [ datetime ] = None , ) -> List [ Order ]: ... The above is a rather classic example of a paginated \"GET\" request: page is a required query parameter of type int . It has no default value and as such has to be provided or a ValidationException will be raised. page_size is a required query parameter of type int as well, but it has a default value - so it can be omitted in the request. brands is an optional list of strings with a default None value. from_date and to_date are optional date-time values that have a default None value. These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. This works great, but what happens when the request is sent with a non-python naming scheme, such as camelCase ? You could of course simply rename your variables accordingly: from datetime import datetime from typing import Optional , List from starlite import get from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , brands : List [ str ], pageSize : int = 10 , fromDate : Optional [ datetime ] = None , toDate : Optional [ datetime ] = None , ) -> List [ Order ]: ... This doesn't look so good, and tools such as PyLint will complain. The solution here is to use the Parameter function : from datetime import datetime from typing import Optional , List from starlite import get , Parameter from my_app.models import Order @get ( path = \"/orders\" ) def get_orders ( page : int , page_size : int = Parameter ( query = \"pageSize\" , gt = 0 , le = 100 ), brands : List [ str ] = Parameter ( min_items = 2 , max_items = 5 ), from_Date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), to_date : Optional [ datetime ] = Parameter ( query = \"fromDate\" ), ) -> List [ Order ]: ... As you can see, specifying the \"query\" kwarg allows us to remap from one key to another. Furthermore, we can use Parameter for extended validation and documentation, as is done for page_size .","title":"Query Parameters"},{"location":"usage/3-parameters/#header-and-cookie-parameters","text":"Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , token : Parameter ( header = \"X-API-KEY\" ), ) -> User : ... OR from pydantic import UUID4 from starlite import get , Parameter from my_app.models import User @get ( path = \"/users/{user_id:uuid}/\" ) async def get_user ( user_id : UUID4 , cookie : Parameter ( cookie = \"my-cookie-param\" ), ) -> User : ... As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters.","title":"Header and Cookie Parameters"},{"location":"usage/3-parameters/#the-parameter-function","text":"Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. Parameter accepts the following optional kwargs: header : The header parameter key for this parameter. A value for this kwarg is required for header parameters. cookie : The cookie parameter key for this parameter. A value for this kwarg is required for cookie parameters. query : The query parameter key for this parameter. examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . required : A boolean flag dictating whether this parameter is required. If set to False , None values will be allowed. Defaults to True . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.","title":"The Parameter Function"},{"location":"usage/4-request-body/","text":"Request Body For all http requests, except GET requests, you can access the request body by specifying the data kwarg in your handler function or method: from starlite import post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... Because User in the above example is a pydantic model you get the benefit of validation and a decent schema generation out of the box. The Body Function For extended validation and supplying schema data, use the Body function: from starlite import Body , post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ) ) -> User : ... The Body function is very similar to the Parameter function , and it receives the following kwargs: media_type : An instance of the starlite.enums.RequestEncodingType enum. Defaults to RequestEncodingType.JSON . examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. URL Encoded Form Data To access url encoded form data, i.e. data sent with an application/x-www-form-urlencoded Content-Type header, you need to use Body and specify RequestEncodingType.URL_ENCODED as the media_type kwarg: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : ... The above ensures that Starlite will inject data using the request.form() method rather than request.json(). It also causes the generated OpenAPI schema to use the correct media type. Important url encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures, e.g. frontend forms. MultiPart Form Data Multipart formdata supports complex formdata including file uploads. You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : ... Accessing Files In case of files uploaded, Starlette transforms the results into an instance of starlette.datastructures.UploadFile , which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... To access multiple files with known filenames, you can use a pydantic model: my_app/models.py from pydantic import BaseModel from starlette.datastructures import UploadFile class FormData ( BaseModel ): cv : UploadFile image : UploadFile class Config : arbitrary_types_allowed = True from starlite import Body , post , RequestEncodingType from my_app.models import FormData @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... If you do not care about parsing and validation and only want to access the form data as a dictionary, you can do this: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import Dict @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : Dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ) ) -> None : ... Finally, if you do not know the filenames are do not care about them, you can get the files as a list: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import List @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : List [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ...","title":"Request Body"},{"location":"usage/4-request-body/#request-body","text":"For all http requests, except GET requests, you can access the request body by specifying the data kwarg in your handler function or method: from starlite import post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User ) -> User : ... Because User in the above example is a pydantic model you get the benefit of validation and a decent schema generation out of the box.","title":"Request Body"},{"location":"usage/4-request-body/#the-body-function","text":"For extended validation and supplying schema data, use the Body function: from starlite import Body , post from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ) ) -> User : ... The Body function is very similar to the Parameter function , and it receives the following kwargs: media_type : An instance of the starlite.enums.RequestEncodingType enum. Defaults to RequestEncodingType.JSON . examples : A list of Example models. external_docs : A url pointing at external documentation for the given parameter. content_encoding : The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details . default : A default value. If const is true, this value is required. title : String value used in the title section of the OpenAPI schema for the given parameter. description : String value used in the description section of the OpenAPI schema for the given parameter. const : A boolean flag dictating whether this parameter is a constant. If True , the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. gt : Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. ge : Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. lt : Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. le : Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. multiple_of : Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. min_items : Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. max_items : Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. min_length : Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. max_length : Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. regex : A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.","title":"The Body Function"},{"location":"usage/4-request-body/#url-encoded-form-data","text":"To access url encoded form data, i.e. data sent with an application/x-www-form-urlencoded Content-Type header, you need to use Body and specify RequestEncodingType.URL_ENCODED as the media_type kwarg: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : ... The above ensures that Starlite will inject data using the request.form() method rather than request.json(). It also causes the generated OpenAPI schema to use the correct media type. Important url encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures, e.g. frontend forms.","title":"URL Encoded Form Data"},{"location":"usage/4-request-body/#multipart-form-data","text":"Multipart formdata supports complex formdata including file uploads. You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from starlite import Body , post , RequestEncodingType from my_app.models import User @post ( path = \"/user\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : ...","title":"MultiPart Form Data"},{"location":"usage/4-request-body/#accessing-files","text":"In case of files uploaded, Starlette transforms the results into an instance of starlette.datastructures.UploadFile , which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... To access multiple files with known filenames, you can use a pydantic model: my_app/models.py from pydantic import BaseModel from starlette.datastructures import UploadFile class FormData ( BaseModel ): cv : UploadFile image : UploadFile class Config : arbitrary_types_allowed = True from starlite import Body , post , RequestEncodingType from my_app.models import FormData @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ... If you do not care about parsing and validation and only want to access the form data as a dictionary, you can do this: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import Dict @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : Dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ) ) -> None : ... Finally, if you do not know the filenames are do not care about them, you can get the files as a list: from starlette.datastructures import UploadFile from starlite import Body , post , RequestEncodingType from typing import List @post ( path = \"/file-upload\" ) async def handle_file_upload ( data : List [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> None : ...","title":"Accessing Files"},{"location":"usage/5-responses/","text":"Responses When you return a value from a route handler function, Starlite takes the value and passes it to the constructor of the Starlite Response class ( starlite.response.Response ), as the response's content kwarg. It also sets the response's status_code and media_type kwargs based on either what was defined in the route handler decorator or default values. For example, lets assume we have a model named Resource which we persist using some orm abstracted into a repository: my_api/models/resource.py from pydantic import BaseModel class Resource ( BaseModel ): id : int name : str We have a route handler that takes a resource_id kwarg, passed as a path parameter, which is then used to retrieve the persisted resource from the DB: from starlite import get from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" ) async def retrieve_resource ( resource_id : int ) -> Resource : return await ResourceRepository . find ( id = resource_id ) Once the retrieve_resource handler returns, Starlite will use the return value to create a Response instance. The status_code of the response will be HTTP_200_OK , which is the default for GET, and a media_type of MediaType.JSON , which is the default media type. As a result the return value, which is a pydantic model, will be serialized into JSON, and the response's Content-Type header will be set to \"application/json\". Status Codes You can specify a status_code to set for the response as a decorator kwarg: from starlite import get from starlette.status import HTTP_202_ACCEPTED from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" , status_code = HTTP_202_ACCEPTED ) async def retrieve_resource ( resource_id : int ) -> Resource : resource = await ResourceRepository . find ( id = resource_id ) return resource Setting the status_code kwarg is optional for delete , get , patch , post and put decorators, and also for the route decorators when only setting a single http_method . If not set by the user, the following defaults will be used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Please note that when designating a function as a handler for multiple http methods, a status_code kwarg must be passed or an exception will be raised. Also note that the default for delete is no content because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can specify write integers as the value for status_code , e.g. status_code=200 , its best practice to use constants (also in tests). Starlette includes easy to use statuses that are exported from starlette.status , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the official docs . Media Type As previously mentioned, the default media type is MediaType.JSON , which translates into a response with the \"Content-Type\" header of application/json . MediaType here is a Starlite enum ( starlite.enums.MediaType ) which is used for convenience - you can pass a string value as well but should ensure that it is a legitimate value according to the receiver / OpenAPI specs. This enum has 3 members, each correlating with a specific Content-Type header: MediaType.JSON: application/json MediaType.TEXT: text/plain MediaType.HTML: text/html The return value of the handler should correlate with the media_type of the function (see below). Text Responses For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" HTML Responses For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string. JSON Responses As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models numpy ndarray lists containing any of the above elements Since Starlite uses the excellent (and super-fast!) orjson library to handle JSON (also in requests), you can use the following values as part of your responses without issue: all UUIDs datetime classes numpy primitives and objects (see orjson docs ) If you need to return other values and would like to extend serialization you can do this using Custom Responses . Response Types Not all responses can be inferred using the media_type kwarg, and for these types of responses Starlite relies on special wrapper classes. Redirect Responses Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import get , Redirect @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path File Responses File responses send a file: from pathlib import Path from starlite import get , File @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import get , File @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) Streaming Responses To return a streaming response use the Stream class: from asyncio import sleep from starlite import get , Stream from datetime import datetime from orjson import dumps async def my_iterator () -> bytes : while True : await sleep ( 0.01 ) yield dumps ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_iterator ) The Stream class receives a single required kwarg - iterator , which should be either a sync or an async iterator. Using Custom Responses You can use a subclass of starlite.responses.Response and specify it as the response class using the response_class kwarg. For example, lets say we want to handle subclasses of Document from the elasticsearch_dsl package as shown below: from elasticsearch_dsl import Document , Integer , Keyword class MyDocument ( Document ): name = Keyword () level = Integer () type = Keyword () It would be best if we had a generic response class that was able to handle all Document subclasses. Luckily, the Document model already comes with a to_dict method, which makes our lives a bit simpler: from typing import Any , Dict from elasticsearch_dsl import Document from starlite import Response class DocumentResponse ( Response ): def serializer ( self , value : Any ) -> Dict [ str , Any ]: if isinstance ( value , Document ): return value . to_dict () return super () . serializer ( value ) We can now use this in our route handler: from elasticsearch_dsl import Document from starlite import get from my_app.responses import DocumentResponse @get ( path = \"/document\" , response_class = DocumentResponse ) def get_document () -> Document : ... You can specify the response class to use at all levels of your application. On specific route handlers, on a controller, a router even on the app instance itself: from starlite import Controller , Starlite , Router from my_app.responses import DocumentResponse # controller class MyController ( Controller ): path = \"...\" response_class = DocumentResponse # router my_router = Router ( path = \"...\" , route_handlers = [ ... ], response_class = DocumentResponse ) # app my_app = Starlite ( route_handlers = [ ... ], response_class = DocumentResponse ) When you specify a response_class in multiple places, the closest layer to the response handler will take precedence. That is, the response_class specified on the route handler takes precedence over the one specified on the controller or router, which will in turn take precedence over the one specified on the app level. You can therefore easily override response classes as needed. Returning Responses Directly You can return an instance of any Starlette response, including the Starlite Response and subclasses thereof from a route handler function: from starlite import get from starlette.responses import Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) OR from starlite import get , Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) Important If you return a response directly the OpenAPI schema generation will not be able to properly annotate the response. Response Headers To add headers to a response use the ResponseHeader model: from starlite import ResponseHeader , get @get ( path = \"/\" , response_headers = { \"my-header\" : ResponseHeader ( value = \"secret\" , description = \"super secret header\" ) }, ) def my_route_handler () -> None : ... You can declare response headers on all layers of the app - individual route handlers, controllers, routers and the app itself. This works like dependencies - that is, lower levels override higher levels.","title":"Responses"},{"location":"usage/5-responses/#responses","text":"When you return a value from a route handler function, Starlite takes the value and passes it to the constructor of the Starlite Response class ( starlite.response.Response ), as the response's content kwarg. It also sets the response's status_code and media_type kwargs based on either what was defined in the route handler decorator or default values. For example, lets assume we have a model named Resource which we persist using some orm abstracted into a repository: my_api/models/resource.py from pydantic import BaseModel class Resource ( BaseModel ): id : int name : str We have a route handler that takes a resource_id kwarg, passed as a path parameter, which is then used to retrieve the persisted resource from the DB: from starlite import get from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" ) async def retrieve_resource ( resource_id : int ) -> Resource : return await ResourceRepository . find ( id = resource_id ) Once the retrieve_resource handler returns, Starlite will use the return value to create a Response instance. The status_code of the response will be HTTP_200_OK , which is the default for GET, and a media_type of MediaType.JSON , which is the default media type. As a result the return value, which is a pydantic model, will be serialized into JSON, and the response's Content-Type header will be set to \"application/json\".","title":"Responses"},{"location":"usage/5-responses/#status-codes","text":"You can specify a status_code to set for the response as a decorator kwarg: from starlite import get from starlette.status import HTTP_202_ACCEPTED from my_api.models import Resource from my_api.db import ResourceRepository @get ( path = \"/resources/{resource_id:int}\" , status_code = HTTP_202_ACCEPTED ) async def retrieve_resource ( resource_id : int ) -> Resource : resource = await ResourceRepository . find ( id = resource_id ) return resource Setting the status_code kwarg is optional for delete , get , patch , post and put decorators, and also for the route decorators when only setting a single http_method . If not set by the user, the following defaults will be used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Please note that when designating a function as a handler for multiple http methods, a status_code kwarg must be passed or an exception will be raised. Also note that the default for delete is no content because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can specify write integers as the value for status_code , e.g. status_code=200 , its best practice to use constants (also in tests). Starlette includes easy to use statuses that are exported from starlette.status , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the official docs .","title":"Status Codes"},{"location":"usage/5-responses/#media-type","text":"As previously mentioned, the default media type is MediaType.JSON , which translates into a response with the \"Content-Type\" header of application/json . MediaType here is a Starlite enum ( starlite.enums.MediaType ) which is used for convenience - you can pass a string value as well but should ensure that it is a legitimate value according to the receiver / OpenAPI specs. This enum has 3 members, each correlating with a specific Content-Type header: MediaType.JSON: application/json MediaType.TEXT: text/plain MediaType.HTML: text/html The return value of the handler should correlate with the media_type of the function (see below).","title":"Media Type"},{"location":"usage/5-responses/#text-responses","text":"For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\"","title":"Text Responses"},{"location":"usage/5-responses/#html-responses","text":"For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.","title":"HTML Responses"},{"location":"usage/5-responses/#json-responses","text":"As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models numpy ndarray lists containing any of the above elements Since Starlite uses the excellent (and super-fast!) orjson library to handle JSON (also in requests), you can use the following values as part of your responses without issue: all UUIDs datetime classes numpy primitives and objects (see orjson docs ) If you need to return other values and would like to extend serialization you can do this using Custom Responses .","title":"JSON Responses"},{"location":"usage/5-responses/#response-types","text":"Not all responses can be inferred using the media_type kwarg, and for these types of responses Starlite relies on special wrapper classes.","title":"Response Types"},{"location":"usage/5-responses/#redirect-responses","text":"Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlette.status import HTTP_307_TEMPORARY_REDIRECT from starlite import get , Redirect @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path","title":"Redirect Responses"},{"location":"usage/5-responses/#file-responses","text":"File responses send a file: from pathlib import Path from starlite import get , File @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import get , File @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , )","title":"File Responses"},{"location":"usage/5-responses/#streaming-responses","text":"To return a streaming response use the Stream class: from asyncio import sleep from starlite import get , Stream from datetime import datetime from orjson import dumps async def my_iterator () -> bytes : while True : await sleep ( 0.01 ) yield dumps ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_iterator ) The Stream class receives a single required kwarg - iterator , which should be either a sync or an async iterator.","title":"Streaming Responses"},{"location":"usage/5-responses/#using-custom-responses","text":"You can use a subclass of starlite.responses.Response and specify it as the response class using the response_class kwarg. For example, lets say we want to handle subclasses of Document from the elasticsearch_dsl package as shown below: from elasticsearch_dsl import Document , Integer , Keyword class MyDocument ( Document ): name = Keyword () level = Integer () type = Keyword () It would be best if we had a generic response class that was able to handle all Document subclasses. Luckily, the Document model already comes with a to_dict method, which makes our lives a bit simpler: from typing import Any , Dict from elasticsearch_dsl import Document from starlite import Response class DocumentResponse ( Response ): def serializer ( self , value : Any ) -> Dict [ str , Any ]: if isinstance ( value , Document ): return value . to_dict () return super () . serializer ( value ) We can now use this in our route handler: from elasticsearch_dsl import Document from starlite import get from my_app.responses import DocumentResponse @get ( path = \"/document\" , response_class = DocumentResponse ) def get_document () -> Document : ... You can specify the response class to use at all levels of your application. On specific route handlers, on a controller, a router even on the app instance itself: from starlite import Controller , Starlite , Router from my_app.responses import DocumentResponse # controller class MyController ( Controller ): path = \"...\" response_class = DocumentResponse # router my_router = Router ( path = \"...\" , route_handlers = [ ... ], response_class = DocumentResponse ) # app my_app = Starlite ( route_handlers = [ ... ], response_class = DocumentResponse ) When you specify a response_class in multiple places, the closest layer to the response handler will take precedence. That is, the response_class specified on the route handler takes precedence over the one specified on the controller or router, which will in turn take precedence over the one specified on the app level. You can therefore easily override response classes as needed.","title":"Using Custom Responses"},{"location":"usage/5-responses/#returning-responses-directly","text":"You can return an instance of any Starlette response, including the Starlite Response and subclasses thereof from a route handler function: from starlite import get from starlette.responses import Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) OR from starlite import get , Response @get ( path = \"/\" ) def my_route_handler () -> Response : return Response ( ... ) Important If you return a response directly the OpenAPI schema generation will not be able to properly annotate the response.","title":"Returning Responses Directly"},{"location":"usage/5-responses/#response-headers","text":"To add headers to a response use the ResponseHeader model: from starlite import ResponseHeader , get @get ( path = \"/\" , response_headers = { \"my-header\" : ResponseHeader ( value = \"secret\" , description = \"super secret header\" ) }, ) def my_route_handler () -> None : ... You can declare response headers on all layers of the app - individual route handlers, controllers, routers and the app itself. This works like dependencies - that is, lower levels override higher levels.","title":"Response Headers"},{"location":"usage/6-dependency-injection/","text":"Dependency Injection Starlite has a simple but powerful dependency injection system. To explain how it works lets begin with 4 different functions, each returning a different kind of value: def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... We can declare dependencies on different levels of the application using the Provide class: from starlite import Controller , Router , Starlite , Provide , get from my_app.dependencies import bool_fn , dict_fn , int_fn , list_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) In the above example, the route handler function my_route_handler has four different dependencies injected into it as kwargs. Pre-requisites and Scope The pre-requisites for dependency injection are these: dependencies must be callables (sync or async). dependencies can receive kwargs and a self arg but not other args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers. Dependency Kwargs As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers except other dependencies. Let's say we have a model called Wallet , which we'll assume we persist in a DB: my_app/models.py from pydantic import BaseModel , UUID4 class Wallet ( BaseModel ): id : UUID4 currency : str value : float We have a WalletController class with basic CRUD route handlers: my_app/wallet/controller.py from starlite import Controller , Partial , delete , get , patch , post from my_app.models import Wallet class WalletController ( Controller ): path = \"/wallet\" @post () async def create_wallet ( self , data : Wallet ) -> Wallet : ... @get ( path = \"/{wallet_id:uuid}\" ) async def retrieve_wallet ( self , wallet : Wallet ) -> Wallet : ... @patch ( path = \"/{wallet_id:uuid}\" ) async def update_wallet ( self , data : Partial [ Wallet ], wallet : Wallet ) -> Wallet : ... @delete ( path = \"/{wallet_id:uuid}\" ) async def delete_wallet ( self , wallet : Wallet ) -> None : ... We need to inject the wallet instance into the retrieve_wallet , update_wallet and delete_wallet routes. To do this we will create a dependency that takes a wallet_id kwarg and then retrieves the instance from the DB: my_app/dependencies.py from pydantic import UUID4 from my_app.models import Wallet async def get_wallet_by_id ( waller_id : UUID4 ) -> Wallet : ... We will now set it on the controller with the correct keyword: my_app/wallet/controller.py from starlite import Controller , Provide from my_app.dependencies import get_wallet_by_id class WalletController ( Controller ): path = \"/wallet\" dependencies = { \"wallet\" : Provide ( get_wallet_by_id ) } # ... This is it - since the controller methods declared the correct path parameter, this value will be passed into the get_wallet_by_id . Overriding Dependencies Because dependencies are declared at each level using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get from my_app.dependencies import bool_fn , dict_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... As you can see in the above - the lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one. This logic applies on all layers. The Provide Class Provide is a simple wrapper that takes a callable as a required arg, and an optional kwarg - use_cache . By default Provide will not cache the return value of the dependency, and it will be executed on every call to the route handler that uses it. If use_cache is True , it will cache the return value on the first execution and will not call it again. Important The caching done inside Provide is very simple - it stores the return value and returns it. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option.","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/#dependency-injection","text":"Starlite has a simple but powerful dependency injection system. To explain how it works lets begin with 4 different functions, each returning a different kind of value: def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... We can declare dependencies on different levels of the application using the Provide class: from starlite import Controller , Router , Starlite , Provide , get from my_app.dependencies import bool_fn , dict_fn , int_fn , list_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) In the above example, the route handler function my_route_handler has four different dependencies injected into it as kwargs.","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/#pre-requisites-and-scope","text":"The pre-requisites for dependency injection are these: dependencies must be callables (sync or async). dependencies can receive kwargs and a self arg but not other args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers.","title":"Pre-requisites and Scope"},{"location":"usage/6-dependency-injection/#dependency-kwargs","text":"As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers except other dependencies. Let's say we have a model called Wallet , which we'll assume we persist in a DB: my_app/models.py from pydantic import BaseModel , UUID4 class Wallet ( BaseModel ): id : UUID4 currency : str value : float We have a WalletController class with basic CRUD route handlers: my_app/wallet/controller.py from starlite import Controller , Partial , delete , get , patch , post from my_app.models import Wallet class WalletController ( Controller ): path = \"/wallet\" @post () async def create_wallet ( self , data : Wallet ) -> Wallet : ... @get ( path = \"/{wallet_id:uuid}\" ) async def retrieve_wallet ( self , wallet : Wallet ) -> Wallet : ... @patch ( path = \"/{wallet_id:uuid}\" ) async def update_wallet ( self , data : Partial [ Wallet ], wallet : Wallet ) -> Wallet : ... @delete ( path = \"/{wallet_id:uuid}\" ) async def delete_wallet ( self , wallet : Wallet ) -> None : ... We need to inject the wallet instance into the retrieve_wallet , update_wallet and delete_wallet routes. To do this we will create a dependency that takes a wallet_id kwarg and then retrieves the instance from the DB: my_app/dependencies.py from pydantic import UUID4 from my_app.models import Wallet async def get_wallet_by_id ( waller_id : UUID4 ) -> Wallet : ... We will now set it on the controller with the correct keyword: my_app/wallet/controller.py from starlite import Controller , Provide from my_app.dependencies import get_wallet_by_id class WalletController ( Controller ): path = \"/wallet\" dependencies = { \"wallet\" : Provide ( get_wallet_by_id ) } # ... This is it - since the controller methods declared the correct path parameter, this value will be passed into the get_wallet_by_id .","title":"Dependency Kwargs"},{"location":"usage/6-dependency-injection/#overriding-dependencies","text":"Because dependencies are declared at each level using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get from my_app.dependencies import bool_fn , dict_fn class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... As you can see in the above - the lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one. This logic applies on all layers.","title":"Overriding Dependencies"},{"location":"usage/6-dependency-injection/#the-provide-class","text":"Provide is a simple wrapper that takes a callable as a required arg, and an optional kwarg - use_cache . By default Provide will not cache the return value of the dependency, and it will be executed on every call to the route handler that uses it. If use_cache is True , it will cache the return value on the first execution and will not call it again. Important The caching done inside Provide is very simple - it stores the return value and returns it. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option.","title":"The Provide Class"},{"location":"usage/7-middleware/","text":"Middleware Middlewares are mini ASGI apps that receive the raw request object and validate or transform it in some manner. Middlewares are useful when you need to operate on all incoming requests on the app level. Starlite builds on top of the Starlette middleware architecture and is 100% compatible with it - and any 3rd party middlewares created for it. The Middleware Protocol You can build your own middleware by either subclassing the starlette.middleware.base.BaseMiddleware class (see the starlette documentation), or by creating a class that implements the Starlite MiddlewareProtocol . For example, lets create a simple middleware that does some naive logging for every request: import logging from starlette.types import ASGIApp , Receive , Scope , Send from starlite import MiddlewareProtocol , Request logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) What's happening above? The __init__ method receives and sets \"app\" - app is not an instance of Starlite, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. It's important to note here two things: Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope dictionary, not any ephemeral request objects created as in the above. Once the middleware finishes doing whatever its doing, it should pass scope , receive and send to either self.app or an instance of Response - this is equivalent in other middleware architectures to calling next , which is what happens in the last line of the example. Built-in Middlewares Starlette includes several builtin middlewares - you can see the list in the Starlette docs. Of these middlewares, Starlite offers a simple way to use two of them: CORS CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of starlite.config.CORSConfig to the Starlite constructor: from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) You can pass the following kwargs to CORSConfig: allow_origins : list of domain schemas, defaults to [\"*\"] allow_methods : list of http methods, defaults to [\"*\"] allow_headers : list of header keys, defaults to [\"*\"] allow_credentials : A boolean dictating whether CORS should support cookies in cross-origin requests. Defaults to False . allow_origin_regex : A regex string that is matches against incoming request origins. Defaults to None . expose_headers : A list of response headers to expose. Defaults to [] . max_age : Sets a response header instructing the max amount of seconds that the browser should cache a CORS response. Defaults to 600. Note The asteriks symbol in the above kwargs means \"match any\". You can read more about this middleware in the starlette docs . Trusted Hosts Another common security mechanism is to require that each incoming request has a \"HOST\" header, and then to restrict hosts to a specific set of domains - whats called \"allowed hosts\". To enable this middleware simply pass a list of trusted hosts to the Starlite constructor: from starlite import Starlite app = Starlite ( request_handlers = [ ... ], allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ) You can use * to match any subdomains, as in the above.","title":"Middleware"},{"location":"usage/7-middleware/#middleware","text":"Middlewares are mini ASGI apps that receive the raw request object and validate or transform it in some manner. Middlewares are useful when you need to operate on all incoming requests on the app level. Starlite builds on top of the Starlette middleware architecture and is 100% compatible with it - and any 3rd party middlewares created for it.","title":"Middleware"},{"location":"usage/7-middleware/#the-middleware-protocol","text":"You can build your own middleware by either subclassing the starlette.middleware.base.BaseMiddleware class (see the starlette documentation), or by creating a class that implements the Starlite MiddlewareProtocol . For example, lets create a simple middleware that does some naive logging for every request: import logging from starlette.types import ASGIApp , Receive , Scope , Send from starlite import MiddlewareProtocol , Request logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) What's happening above? The __init__ method receives and sets \"app\" - app is not an instance of Starlite, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. It's important to note here two things: Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope dictionary, not any ephemeral request objects created as in the above. Once the middleware finishes doing whatever its doing, it should pass scope , receive and send to either self.app or an instance of Response - this is equivalent in other middleware architectures to calling next , which is what happens in the last line of the example.","title":"The Middleware Protocol"},{"location":"usage/7-middleware/#built-in-middlewares","text":"Starlette includes several builtin middlewares - you can see the list in the Starlette docs. Of these middlewares, Starlite offers a simple way to use two of them:","title":"Built-in Middlewares"},{"location":"usage/7-middleware/#cors","text":"CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of starlite.config.CORSConfig to the Starlite constructor: from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) You can pass the following kwargs to CORSConfig: allow_origins : list of domain schemas, defaults to [\"*\"] allow_methods : list of http methods, defaults to [\"*\"] allow_headers : list of header keys, defaults to [\"*\"] allow_credentials : A boolean dictating whether CORS should support cookies in cross-origin requests. Defaults to False . allow_origin_regex : A regex string that is matches against incoming request origins. Defaults to None . expose_headers : A list of response headers to expose. Defaults to [] . max_age : Sets a response header instructing the max amount of seconds that the browser should cache a CORS response. Defaults to 600. Note The asteriks symbol in the above kwargs means \"match any\". You can read more about this middleware in the starlette docs .","title":"CORS"},{"location":"usage/7-middleware/#trusted-hosts","text":"Another common security mechanism is to require that each incoming request has a \"HOST\" header, and then to restrict hosts to a specific set of domains - whats called \"allowed hosts\". To enable this middleware simply pass a list of trusted hosts to the Starlite constructor: from starlite import Starlite app = Starlite ( request_handlers = [ ... ], allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ) You can use * to match any subdomains, as in the above.","title":"Trusted Hosts"},{"location":"usage/8-authentication/","text":"Authentication Starlite is agnostic as to what kind of authentication mechanism(s) an app should use - you can use cookies, JWT tokens, OpenID connect depending on your use-case. It also does not implement any of these mechanisms for you. What it does is offer an opinion as to where authentication should occur, namely - as part of your middleware stack. This is in accordance with Starlette and many other frameworks (e.g. Django, NestJS etc.). Authentication Middleware Starlite exports a class called AbstractAuthenticationMiddleware , which, as its name implies, is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app simply subclass AbstractAuthenticationMiddleware and implement the method authenticate_request , which has the following signature: from starlite import AuthenticationResult , Request async def authenticate_request ( request : Request ) -> AuthenticationResult : ... Example: Create a JWT Authentication Middleware For example, lets say we wanted to implement a JWT token based authentication. We start off by creating two pydantic models, one for the user which we persist into some sort of DB, and another for the token data: my_app/models.py from datetime import datetime from pydantic import BaseModel , UUID4 class User ( BaseModel ): id : UUID4 # ... lots of other fields class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 Note In the real world User would be a database model and would be persisted using a 3rd party library. The current example just assumes this is happening. We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library, which is an excellent choice. my_app/utils/jwt.py from datetime import datetime , timedelta from os import environ from jose import JWTError , jwt from starlite import NotAuthorizedException , ValidationException from my_app.models import Token , User DEFAULT_TIME_DELTA = timedelta ( days = 1 ) def decode_jwt_token ( encoded_token : str , secret : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = secret , algorithms = [ \"HS256\" ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e ## not used in the example, but required for real life implementations and testing def encode_jwt_token ( user_id : str , secret : str , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" payload = JWTToken ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( payload , secret , algorithm = \"HS256\" ) def get_jwt_secret () -> str : \"\"\"A getter that retrieves the JWT secret passed as an environment variable\"\"\" secret = environ . get ( \"JWT_SECRET\" ) if not secret : raise ValidationException ( \"Missing required ENV variable 'JWT_SECRET'\" ) return secret We can now create our authentication middleware: my_app/middleware/auth.py from starlite import AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException , Request from my_app.utils.jwt import decode_jwt_token , get_jwt_secret from my_app.persistence import get_connection from my_app.models import User API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , request : Request ) -> AuthenticationResult : \"\"\"Given a request, parse the request api key stored in the header and retrieve the user\"\"\" # retrieve the auth header auth_header = request . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # retrieve the secret from environment secret = get_jwt_secret () # decode the token token = decode_jwt_token ( encoded_token = auth_header , secret = secret ) # retrieve the user from the database using the id that is stored as the sub value # pseudo-code below is similar to the syntax used by the ODMantic and SQLModel libraries user = await get_connection () . find ( User , User . id == token . sub ) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from my_app.middleware.auth import JWTAuthenticationMiddleware app = Starlite ( request_handlers = [ ... ], middleware = [ JWTAuthenticationMiddleware ]) That's it. The JWTAuthenticationMiddleware will now run for every request. Authentication Result The method authenticate_request specified by AbstractAuthenticationMiddleware expects the return value to be an instance of AuthenticationResult . This is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively. Building on the previous example, we would be able to access these in a route handler function or a dependency in the following way: from starlite import Request from my_app.models import User , Token def my_endpoint ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token ...","title":"Authentication"},{"location":"usage/8-authentication/#authentication","text":"Starlite is agnostic as to what kind of authentication mechanism(s) an app should use - you can use cookies, JWT tokens, OpenID connect depending on your use-case. It also does not implement any of these mechanisms for you. What it does is offer an opinion as to where authentication should occur, namely - as part of your middleware stack. This is in accordance with Starlette and many other frameworks (e.g. Django, NestJS etc.).","title":"Authentication"},{"location":"usage/8-authentication/#authentication-middleware","text":"Starlite exports a class called AbstractAuthenticationMiddleware , which, as its name implies, is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app simply subclass AbstractAuthenticationMiddleware and implement the method authenticate_request , which has the following signature: from starlite import AuthenticationResult , Request async def authenticate_request ( request : Request ) -> AuthenticationResult : ...","title":"Authentication Middleware"},{"location":"usage/8-authentication/#example-create-a-jwt-authentication-middleware","text":"For example, lets say we wanted to implement a JWT token based authentication. We start off by creating two pydantic models, one for the user which we persist into some sort of DB, and another for the token data: my_app/models.py from datetime import datetime from pydantic import BaseModel , UUID4 class User ( BaseModel ): id : UUID4 # ... lots of other fields class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 Note In the real world User would be a database model and would be persisted using a 3rd party library. The current example just assumes this is happening. We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library, which is an excellent choice. my_app/utils/jwt.py from datetime import datetime , timedelta from os import environ from jose import JWTError , jwt from starlite import NotAuthorizedException , ValidationException from my_app.models import Token , User DEFAULT_TIME_DELTA = timedelta ( days = 1 ) def decode_jwt_token ( encoded_token : str , secret : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = secret , algorithms = [ \"HS256\" ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e ## not used in the example, but required for real life implementations and testing def encode_jwt_token ( user_id : str , secret : str , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" payload = JWTToken ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( payload , secret , algorithm = \"HS256\" ) def get_jwt_secret () -> str : \"\"\"A getter that retrieves the JWT secret passed as an environment variable\"\"\" secret = environ . get ( \"JWT_SECRET\" ) if not secret : raise ValidationException ( \"Missing required ENV variable 'JWT_SECRET'\" ) return secret We can now create our authentication middleware: my_app/middleware/auth.py from starlite import AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException , Request from my_app.utils.jwt import decode_jwt_token , get_jwt_secret from my_app.persistence import get_connection from my_app.models import User API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , request : Request ) -> AuthenticationResult : \"\"\"Given a request, parse the request api key stored in the header and retrieve the user\"\"\" # retrieve the auth header auth_header = request . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # retrieve the secret from environment secret = get_jwt_secret () # decode the token token = decode_jwt_token ( encoded_token = auth_header , secret = secret ) # retrieve the user from the database using the id that is stored as the sub value # pseudo-code below is similar to the syntax used by the ODMantic and SQLModel libraries user = await get_connection () . find ( User , User . id == token . sub ) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from my_app.middleware.auth import JWTAuthenticationMiddleware app = Starlite ( request_handlers = [ ... ], middleware = [ JWTAuthenticationMiddleware ]) That's it. The JWTAuthenticationMiddleware will now run for every request.","title":"Example: Create a JWT Authentication Middleware"},{"location":"usage/8-authentication/#authentication-result","text":"The method authenticate_request specified by AbstractAuthenticationMiddleware expects the return value to be an instance of AuthenticationResult . This is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively. Building on the previous example, we would be able to access these in a route handler function or a dependency in the following way: from starlite import Request from my_app.models import User , Token def my_endpoint ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token ...","title":"Authentication Result"},{"location":"usage/9-guards/","text":"Guards Guards are callables that receive two arguments - request , which is the Request instance, and route_handler , which is a copy of the RouteHandler model. Their role is to authorize the request by verifying that the request is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : my_app/enums.py from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: my_app/models.py from pydantic import BaseModel , UUID4 from my_app.enums import UserRole class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException from my_app.models import User def admin_user_guard ( request : Request [ User ], _ : RouteHandler ) -> None : if not request . user . is_admin : raise NotAuthorizedException () We can now use it, for example - lets say we have a route handler that allows users to create users: from starlite import post from my_app.guards import admin_user_guard from my_app.models import User @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler. Guard Scopes Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import Controller , Router , Starlite from my_app.guards import admin_user_guard # controller class UserController ( Controller ): path = \"/user\" guards = [ admin_user_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ admin_user_guard ] ) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ admin_user_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine. The Route Handler \"opt\" Key Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. To this end, all route handler decorators can receive the kwarg opt which adds a dictionary of arbitrary values to the route handler. For example: from starlite import get @get ( path = \"/\" , opt = { \"permissions\" : [ ... ]}) def my_route_handler () -> None : ... To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We can now use this in our endpoint of choice like so: from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"Guards"},{"location":"usage/9-guards/#guards","text":"Guards are callables that receive two arguments - request , which is the Request instance, and route_handler , which is a copy of the RouteHandler model. Their role is to authorize the request by verifying that the request is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : my_app/enums.py from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: my_app/models.py from pydantic import BaseModel , UUID4 from my_app.enums import UserRole class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException from my_app.models import User def admin_user_guard ( request : Request [ User ], _ : RouteHandler ) -> None : if not request . user . is_admin : raise NotAuthorizedException () We can now use it, for example - lets say we have a route handler that allows users to create users: from starlite import post from my_app.guards import admin_user_guard from my_app.models import User @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler.","title":"Guards"},{"location":"usage/9-guards/#guard-scopes","text":"Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import Controller , Router , Starlite from my_app.guards import admin_user_guard # controller class UserController ( Controller ): path = \"/user\" guards = [ admin_user_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ admin_user_guard ] ) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ admin_user_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine.","title":"Guard Scopes"},{"location":"usage/9-guards/#the-route-handler-opt-key","text":"Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. To this end, all route handler decorators can receive the kwarg opt which adds a dictionary of arbitrary values to the route handler. For example: from starlite import get @get ( path = \"/\" , opt = { \"permissions\" : [ ... ]}) def my_route_handler () -> None : ... To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request [ User ], route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We can now use this in our endpoint of choice like so: from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"The Route Handler \"opt\" Key"}]}